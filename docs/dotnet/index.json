{
  "Rego/README.html": {
    "href": "Rego/README.html",
    "title": "Rego | Rego",
    "summary": "Rego What is Rego? Rego is a language developed by Open Policy Agent (OPA) for use in defining policies in cloud systems. We think Rego is a great language, and you can learn more about it from the OPA website. However, it has some limitations. Primarily, the interpreter is only accessible via the command line or a web server. Further, the only option for using the language in-process is via an interface in Go. The rego-cpp project provides the ability to integrate Rego natively into a wider range of languages. We currrently support C, C++, Rust, Python and, via this package, .NET, and are largely compatible with v1.8.0 of the language. You can learn more about our implementation on our Github page. Getting Started Here is an example of how to use the library to execute Rego queries: using Rego; var rego = new Interpreter(); // If you provide an object, it will be converted to JSON before // being added to the state. var data0 = new Dictionary<string, object>{ {\"one\", new Dictionary<string, object>{ {\"bar\", \"Foo\"}, {\"baz\", 5}, {\"be\", true}, {\"bop\", 23.4}}}, {\"two\", new Dictionary<string, object>{ {\"bar\", \"Bar\"}, {\"baz\", 12.3}, {\"be\", false}, {\"bop\", 42}}}}; rego.AddData(data0); // You can also provide JSON directly. rego.AddDataJson(\"\"\" { \"three\": { \"bar\": \"Baz\", \"baz\": 15, \"be\": true, \"bop\": 4.23 } } \"\"\"); var objectsSource = \"\"\" package objects rect := {\"width\": 2, \"height\": 4} cube := {\"width\": 3, \"height\": 4, \"depth\": 5} a := 42 b := false c := null d := {\"a\": a, \"x\": [b, c]} index := 1 shapes := [rect, cube] names := [\"prod\", \"smoke1\", \"dev\"] sites := [{\"name\": \"prod\"}, {\"name\": names[index]}, {\"name\": \"dev\"}] e := { a: \"foo\", \"three\": c, names[2]: b, \"four\": d, } f := e[\"dev\"] \"\"\"; rego.AddModule(\"objects\", objectsSource); // inputs can be either JSON or Rego, and provided // as objects (which will be converted to JSON) or as // text. rego.SetInputTerm(\"\"\" { \"a\": 10, \"b\": \"20\", \"c\": 30.0, \"d\": true } \"\"\"); Console.WriteLine(rego.Query(\"[data.one, input.b, data.objects.sites[1]] = x\")); // Result: {\"bindings\":{\"x\":[{\"bar\":\"Foo\", \"baz\":5, \"be\":true, \"bop\":23.4}, \"20\", {\"name\":\"smoke1\"}]}}"
  },
  "api/Rego.Bundle.html": {
    "href": "api/Rego.Bundle.html",
    "title": "Class Bundle | Rego",
    "summary": "Class Bundle Namespace Rego Assembly Rego.dll Encapsulates a Rego bundle, which contains compiled virtual documents and execution plans, the base documents merged into a single JSON hierarchy, and assorted metadata, including the original module files. public class Bundle Inheritance object Bundle Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Handle The underlying pointer in the native library. public RegoBundleHandle Handle { get; } Property Value RegoBundleHandle Node Node representing the bundle. This is null if the bundle was loaded from a binary file. public Node? Node { get; } Property Value Node Ok Whether the bundle is in a valid state. public bool Ok { get; } Property Value bool"
  },
  "api/Rego.BundleFormat.html": {
    "href": "api/Rego.BundleFormat.html",
    "title": "Enum BundleFormat | Rego",
    "summary": "Enum BundleFormat Namespace Rego Assembly Rego.dll public enum BundleFormat Fields Binary = 1 JSON = 0"
  },
  "api/Rego.Input.html": {
    "href": "api/Rego.Input.html",
    "title": "Class Input | Rego",
    "summary": "Class Input Namespace Rego Assembly Rego.dll The Input class allows the creation of inputs to a policy without requiring serialization to JSON. The interface is that of a stack, in which values are pushed and then various operations are used to turn terminal types into more complex ones like objects and arrays. When used, the Input will provide the top of the stack to any downstream consumer (such as SetInput(Input)). public class Input Inheritance object Input Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples Interpreter rego = new(); var input = Input.Create(new Dictionary<string, object>{ { \"a\", 10 }, { \"b\", \"20\" }, { \"c\", 30.0 }, { \"d\", true } }); rego.SetInput(input); Console.WriteLine(rego.Query(\"input.a\")); // {\"expressions\":[10]} Constructors Input() Creates an empty input. public Input() Properties Handle The underlying pointer in the native library. public RegoInputHandle Handle { get; } Property Value RegoInputHandle Node Node object representing the input. public Node Node { get; } Property Value Node Size Number of elements in the Input stack. public uint Size { get; } Property Value uint Methods Array(uint) Take the top size values on the stack and turn them into an array. Stack order will be used. public Input Array(uint size) Parameters size uint Number of values to use Returns Input A reference to this input Boolean(bool) Push a boolean onto the stack. public Input Boolean(bool value) Parameters value bool value Returns Input A reference to this input Create(object) Factory function which creates Inputs from objects. Supported are any object that can map to JSON, including scalar types such as: int long float double string bool IDictionary IList public static Input Create(object value) Parameters value object Object to encode as an input Returns Input A reference to the input Float(double) Push a float onto the stack. public Input Float(double value) Parameters value double value Returns Input A reference to this input Int(long) Push an integer onto the stack. public Input Int(long value) Parameters value long value Returns Input A reference to this input Null() Push a null onto the stack. public Input Null() Returns Input A reference to this input Object(uint) Take the top size values on the stack and turn them into an object. Note that all of these values must be object items in order for this to be valid. public Input Object(uint size) Parameters size uint Number of object items to use Returns Input A reference to this input ObjectItem() Take the top two values on the stack and turn them into an object item. The penultimate value on the stack will be used as the key, and the top of the stack will be the value for that key. Objects are constructed from object items. public Input ObjectItem() Returns Input A reference to this input Set(uint) Take the top size values on the stack and turn them into an array. Identical items will be de-duplicated. public Input Set(uint size) Parameters size uint Number of values to use Returns Input A reference to this input String(string) Push a string onto the stack. public Input String(string value) Parameters value string value Returns Input A reference to this input"
  },
  "api/Rego.Interpreter.html": {
    "href": "api/Rego.Interpreter.html",
    "title": "Class Interpreter | Rego",
    "summary": "Class Interpreter Namespace Rego Assembly Rego.dll Rego interpreter instance. This class provides methods to load modules, data, and input, execute queries, and manage bundles. public class Interpreter Inheritance object Interpreter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples You can use a query alone, without input or data: using Rego; Interpreter rego = new(); Console.WriteLine(rego.Query(\"x=5;y=x + (2 - 4 * 0.25) * -3 + 7.4;2 * 5\")); // {\"expressions\":[true, true, 10], \"bindings\":{\"x\":5, \"y\":9.4}} More typically, a policy will involve base documents (static data) and virtual documents (Rego modules): using System.Collections; using Rego; Interpreter rego = new(); var data0 = new Dictionary<string, object>{ {\"one\", new Dictionary<string, object>{ {\"bar\", \"Foo\"}, {\"baz\", 5}, {\"be\", true}, {\"bop\", 23.4}}}, {\"two\", new Dictionary<string, object>{ {\"bar\", \"Bar\"}, {\"baz\", 12.3}, {\"be\", false}, {\"bop\", 42}}}}; rego.AddData(data0); rego.AddDataJson(\"\"\" { \"three\": { \"bar\": \"Baz\", \"baz\": 15, \"be\": true, \"bop\": 4.23 } } \"\"\"); var objectsSource = \"\"\" package objects rect := {\"width\": 2, \"height\": 4} cube := {\"width\": 3, \"height\": 4, \"depth\": 5} a := 42 b := false c := null d := {\"a\": a, \"x\": [b, c]} index := 1 shapes := [rect, cube] names := [\"prod\", \"smoke1\", \"dev\"] sites := [{\"name\": \"prod\"}, {\"name\": names[index]}, {\"name\": \"dev\"}] e := { a: \"foo\", \"three\": c, names[2]: b, \"four\": d, } f := e[\"dev\"] \"\"\"; rego.AddModule(\"objects.rego\", objectsSource); rego.SetInputTerm(\"\"\" { \"a\": 10, \"b\": \"20\", \"c\": 30.0, \"d\": true } \"\"\"); Console.WriteLine(rego.Query(\"[data.one, input.b, data.objects.sites[1]] = x\")); // {\"bindings\":{\"x\":[{\"bar\":\"Foo\", \"baz\":5, \"be\":true, \"bop\":23.4}, \"20\", {\"name\":\"smoke1\"}]}} When the same policy is going to be queried multiple times with different inputs, it can be more efficient to build a bundle. using System.Collections; using Rego; Interpreter rego_build = new(); rego_build.AddDataJson(\"\"\" {\"a\": 7, \"b\": 13} \"\"\"); rego_build.AddModule(\"example.rego\", \"\"\" package example foo := data.a * input.x + data.b * input.y bar := data.b * input.x + data.a * input.y \"\"\"); var bundle = rego_build.Build(\"x=data.example.foo + data.example.bar\", [\"example/foo\", \"example/bar\"]); rego_build.SaveBundle(\"bundle\", bundle); Interpreter rego_run = new(); rego_run.LoadBundle(\"bundle\"); var input = Input.Create(new Dictionary<string, int> { {\"x\", 104 }, {\"y\", 119 } }); rego_run.SetInput(input); Console.WriteLine(rego_run.QueryBundle(bundle)); // {\"expressions\":[true], \"bindings\":{\"x\":4460}} Console.WriteLine(rego_run.QueryBundle(bundle, \"example/foo\")); // {\"expressions\":[2275]} Constructors Interpreter() Creates a new Rego interpreter instance public Interpreter() Properties BuildInfo Returns build information about the underlying Rego library public static string BuildInfo { get; } Property Value string DebugEnabled Gets or sets whether debug logging of intermediate ASTs is enabled. public bool DebugEnabled { get; set; } Property Value bool Handle Returns the handle to the underlying Rego interpreter instance public RegoHandle Handle { get; } Property Value RegoHandle LogLevel Gets or sets the log level for the interpreter. public LogLevel LogLevel { get; set; } Property Value LogLevel StrictBuiltInErrors Gets or sets whether built-in functions will raise an error on invalid input. public bool StrictBuiltInErrors { get; set; } Property Value bool Version Returns the version of the underlying Rego library public static string Version { get; } Property Value string WellFormedChecksEnabled Gets or sets whether well-formedness checks are enabled. public bool WellFormedChecksEnabled { get; set; } Property Value bool Methods AddDataJson(string) Adds a base document in JSON format. public void AddDataJson(string json) Parameters json string JSON representation of the document Examples Interpreter rego = new(); var data = \"\"\" { \"one\": { \"bar\": \"Foo\", \"baz\": 5, \"be\": true, \"bop\": 23.4 }, \"two\": { \"bar\": \"Bar\", \"baz\": 12.3, \"be\": false, \"bop\": 42 } } \"\"\"; rego.AddDataJson(data); Console.WriteLine(rego.Query(\"data.one.bar\")); // {\"expressions\":[\"Foo\"]} Exceptions RegoException AddData<T>(T) Adds a base document by serializing the provided object to JSON. public void AddData<T>(T data) Parameters data T The data to serialize Type Parameters T Exceptions RegoException AddModule(string, string) Adds a new Rego module to the interpreter public void AddModule(string name, string source) Parameters name string The name of the module source string The source code of the module Examples using Rego; Interpreter rego = new(); var source = \"\"\" package scalars greeting := \"Hello\" max_height := 42 pi := 3.14159 allowed := true location := null \"\"\"; rego.AddModule(\"scalars.rego\", source); Console.WriteLine(rego.Query(\"data.scalars.greeting\")); // {\"expressions\":[\"Hello\"]} Exceptions RegoException Build(string) Builds a bundle from the loaded modules and data, setting the specified query as the bundle's entrypoint. public Bundle Build(string query) Parameters query string The Rego query string Returns Bundle The created bundle Exceptions RegoException Build(string, string[]) Builds a bundle from the loaded modules and data, setting the specified query and entrypoints as the bundle's entrypoints. Entrypoints are of the format [path/to/rule]. public Bundle Build(string query, string[] entrypoints) Parameters query string entrypoints string[] The Rego entrypoints Returns Bundle The created bundle Examples var input = new Dictionary<string, int>{ {\"x\", 104 }, {\"y\", 119 }}; var data = new Dictionary<string, int>{ {\"a\", 7}, {\"b\", 13}}; var module = \"\"\" package example foo := data.a * input.x + data.b * input.y bar := data.b * input.x + data.a * input.y \"\"\"; Interpreter rego_build = new(); rego_build.AddData(data); rego_build.AddModule(\"example.rego\", module); var bundle = rego_build.Build(\"x=data.example.foo + data.example.bar\", [\"example/foo\", \"example/bar\"]); Interpreter rego_run = new(); rego_run.SetInput(input); Console.WriteLine(rego_run.QueryBundle(bundle)); // {\"expressions\":[true], \"bindings\":{\"x\":4460}} Console.WriteLine(rego_run.QueryBundle(bundle, \"example/foo\")); // {\"expressions\":[2275]} Exceptions RegoException Build(string[]) Builds a bundle from the loaded modules and data, setting the specified entrypoints. Entrypoints are of the format [path/to/rule]. public Bundle Build(string[] entrypoints) Parameters entrypoints string[] The Rego entrypoints Returns Bundle The created bundle Exceptions RegoException IsAvailableBuiltIn(string) Returns whether the specified string corresponds to a known built-in function. public bool IsAvailableBuiltIn(string name) Parameters name string The name of the built-in function Returns bool True if the function is built-in, false otherwise LoadBundle(string, BundleFormat) Loads a bundle from the specified path. The path should point to a directory containing a bundle in JSON format, or to a file containing a bundle in binary format public Bundle LoadBundle(string path, BundleFormat format = BundleFormat.JSON) Parameters path string The path to the bundle format BundleFormat The format of the bundle Returns Bundle The loaded bundle Exceptions ArgumentException RegoException Query(string) Executes a query against the loaded modules, data, and input. public Output Query(string query) Parameters query string Rego query string Returns Output The query output Examples Interpreter rego = new(); var input0 = new Dictionary<string, int> { { \"a\", 10 } }; var input1 = new Dictionary<string, int> { { \"a\", 4 } }; var input2 = new Dictionary<string, int> { { \"a\", 7 } }; var multi = \"\"\" package multi default a := 0 a := val { input.a > 0 input.a < 10 input.a % 2 == 1 val := input.a * 10 } { input.a > 0 input.a < 10 input.a % 2 == 0 val := input.a * 10 + 1 } a := input.a / 10 { input.a >= 10 } \"\"\"; rego.AddModule(\"multi.rego\", multi); rego.SetInput(input0); Console.WriteLine(rego.Query(\"data.multi.a\")); // {\"expressions\":[1]} rego.SetInput(input1); Console.WriteLine(rego.Query(\"data.multi.a\")); // {\"expressions\":[41]} rego.SetInput(input2); Console.WriteLine(rego.Query(\"data.multi.a\")); // {\"expressions\":[70]} Exceptions RegoException QueryBundle(Bundle) Executes a query against the specified bundle. This requires that Build(string) was provided with a query when this bundle was built. public Output QueryBundle(Bundle bundle) Parameters bundle Bundle The bundle to query Returns Output The query output Exceptions RegoException QueryBundle(Bundle, string) Executes a query against the specified bundle, using the specified entrypoint. This requires that Build(string) was provided with the specified entrypoint when this bundle was built. public Output QueryBundle(Bundle bundle, string entrypoint) Parameters bundle Bundle The bundle to query entrypoint string The entrypoint to use for the query Returns Output The query output Exceptions RegoException SaveBundle(string, Bundle, BundleFormat) Saves the specified bundle to the specified path. The path should point to a directory where the bundle will be saved in JSON format, or to a file where the bundle will be saved in binary format. public void SaveBundle(string path, Bundle bundle, BundleFormat format = BundleFormat.JSON) Parameters path string The path to the bundle bundle Bundle The bundle to save format BundleFormat The format of the bundle Examples Interpreter rego_build = new(); var bundle = rego_build.Build(\"a=1\"); rego_build.SaveBundle(\"bundle_doctest1\", bundle); rego_build.SaveBundle(\"bundle_bin_doctest1.rbb\", bundle, BundleFormat.Binary); Interpreter rego_run = new(); bundle = rego_run.LoadBundle(\"bundle_doctest1\"); Console.WriteLine(rego_run.QueryBundle(bundle)); // {\"expressions\":[true], \"bindings\":{\"a\":1}} bundle = rego_run.LoadBundle(\"bundle_bin_doctest1.rbb\", BundleFormat.Binary); Console.WriteLine(rego_run.QueryBundle(bundle)); // {\"expressions\":[true], \"bindings\":{\"a\":1}} Exceptions ArgumentException RegoException SetDebugPath(string) Sets the root of the directory tree where debug ASTs will be written. It will be created if it does not exist. public void SetDebugPath(string path) Parameters path string Path to a directory Exceptions RegoException SetInput(Input) Sets the input document from an Input object. public void SetInput(Input input) Parameters input Input The input object Examples Interpreter rego = new(); var input = Input.Create(new Dictionary<string, int> { {\"x\", 104 }, {\"y\", 119 } }); rego.SetInput(input); Console.WriteLine(rego.Query(\"x=input.x\")); // {\"expressions\":[true], \"bindings\":{\"x\":104}} Exceptions RegoException SetInputTerm(string) Sets the input document from a Rego term. public void SetInputTerm(string term) Parameters term string The Rego term Examples Interpreter rego = new(); var input = \"\"\" { \"a\": 10, \"b\": \"20\", \"c\": 30.0, \"d\": true } \"\"\"; rego.SetInputTerm(input); Console.WriteLine(rego.Query(\"input.a\")); // {\"expressions\":[10]} Exceptions RegoException SetInput<T>(T) Sets the input document by serializing the provided object to JSON. public void SetInput<T>(T data) Parameters data T The data to serialize Type Parameters T Exceptions RegoException"
  },
  "api/Rego.LogLevel.html": {
    "href": "api/Rego.LogLevel.html",
    "title": "Enum LogLevel | Rego",
    "summary": "Enum LogLevel Namespace Rego Assembly Rego.dll Log levels for Rego logging public enum LogLevel Fields Debug = 5 Error = 1 Info = 4 None = 0 Output = 2 Trace = 6 Warn = 3"
  },
  "api/Rego.Logging.html": {
    "href": "api/Rego.Logging.html",
    "title": "Class Logging | Rego",
    "summary": "Class Logging Namespace Rego Assembly Rego.dll Logging utilities for Rego public static class Logging Inheritance object Logging Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods SetDefaultLogLevel(LogLevel) Sets the default log level for Rego logging. The default log level is Output. public static void SetDefaultLogLevel(LogLevel level) Parameters level LogLevel The log level to set Exceptions ArgumentException"
  },
  "api/Rego.Node.html": {
    "href": "api/Rego.Node.html",
    "title": "Class Node | Rego",
    "summary": "Class Node Namespace Rego Assembly Rego.dll Interface for a Rego Node. Rego Nodes are the basic building blocks of a Rego result. They exist in a tree structure. Each node has a kind, which is one of the variants of NodeType. Each node also has zero or more children, which are also nodes. public class Node : IList<Node>, ICollection<Node>, IEnumerable<Node>, IEnumerable Inheritance object Node Implements IList<Node> ICollection<Node> IEnumerable<Node> IEnumerable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Examples Interpreter rego = new(); var output = rego.Query(\"\"\"x={\"a\": 10, \"b\": \"20\", \"c\": [30.5, 60], \"d\": true, \"e\": null}\"\"\"); var x = output.Binding(\"x\"); Console.WriteLine(x); // {\"a\":10, \"b\":\"20\", \"c\":[30.5,60], \"d\":true, \"e\":null} Console.WriteLine(x[\"a\"]); // 10 Console.WriteLine(x[\"b\"]); // \"20\" Console.WriteLine(x[\"c\"][0]); // 30.5 Console.WriteLine(x[\"c\"][1]); // 60 Console.WriteLine(x[\"d\"]); // true Console.WriteLine(x[\"e\"]); // null Properties Count The number of child nodes. public int Count { get; } Property Value int IsReadOnly Indicates whether the collection is read-only. This is always true. public bool IsReadOnly { get; } Property Value bool this[object] Returns a child node by key or index. If the node is a Term, the first child is used as the base node. If the node is an Object or Set, the child with the specified key is returned. If the node is an Array, Terms, or Results, the child at the specified index is returned. For other node types, an exception is thrown. public Node this[object key] { get; set; } Parameters key object the key or index of the child node Property Value Node the child node Exceptions ArgumentException NotSupportedException Keys The keys of the child nodes, if this node is an Object or Set. If the node is a Term, the first child is used as the base node. For other node types, an empty collection is returned. The keys are the JSON representation of the child nodes. public ICollection<string> Keys { get; } Property Value ICollection<string> Pointer Pointer to the underlying native node. public nint Pointer { get; } Property Value nint Type The type of this node. public NodeType Type { get; } Property Value NodeType Value The value of this node, if it is a scalar type (int, float, string, true, false, null). If the node is a Term or Scalar, the value of the first child is returned. For other node types, an exception is thrown. The value is cached after the first call. public object Value { get; } Property Value object Examples Interpreter rego = new(); var output = rego.Query(\"\"\"x=10; y=\"20\"; z=true\"\"\"); Console.WriteLine(output.Binding(\"x\").Value); // 10 Console.WriteLine(output.Binding(\"y\").Value); // \"20\" Console.WriteLine(output.Binding(\"z\").Value); // True Exceptions RegoException Methods Add(Node) Adds a child node. This is not supported and will always throw an exception. public void Add(Node value) Parameters value Node Exceptions NotSupportedException At(int) Returns the child node at the specified index. If the node is a Term, the first child is returned. The child node is cached after the first call. public Node At(int index) Parameters index int Index of the child node Returns Node The child node at the specified index Exceptions IndexOutOfRangeException RegoException Clear() Clears all child nodes. This is not supported and will always throw an exception. public void Clear() Exceptions NotSupportedException Contains(Node) Checks if the specified node is a child of this node. If the node is a Term, the first child is used as the base node. For other node types, the child nodes are checked. The comparison is done by comparing the JSON representation of the nodes. public bool Contains(Node value) Parameters value Node the Node to check Returns bool whether the node is a child of this node ContainsKey(object) Checks if the specified key exists in the child nodes. If the node is a Term, the first child is used as the base node. If the node is an Object or Set, the keys are checked. For other node types, an exception is thrown. The comparison is done by comparing the JSON representation of the keys. public bool ContainsKey(object key) Parameters key object the key to check Returns bool true if the key exists; otherwise, false CopyTo(Node[], int) Copies the child nodes to the specified array, starting at the specified index. If the node is a Term, the first child is used as the base node. For other node types, the child nodes are copied. public void CopyTo(Node[] array, int index) Parameters array Node[] The array to copy the child nodes to. index int The zero-based index at which copying begins. GetEnumerator() Returns an enumerator that iterates through the child nodes. If the node is a Term, the first child is used as the base node. For other node types, the child nodes are iterated. public IEnumerator<Node> GetEnumerator() Returns IEnumerator<Node> the enumerator Index(int) Returns the child node at the specified index. If the node is a Term, the first child is used as the base node. If the node is an Array, Terms, or Results, the child at the specified index is returned. For other node types, an exception is thrown. public Node Index(int index) Parameters index int Index of the child node Returns Node The child node at the specified index Exceptions NotSupportedException IndexOutOfRangeException RegoException IndexOf(Node) Returns the index of the specified child node. If the node is a Term, the first child is used as the base node. For other node types, the child nodes are checked. The comparison is done by comparing the JSON representation of the nodes. If the node is not found, -1 is returned. public int IndexOf(Node value) Parameters value Node the Node to find Returns int the index of the child node, or -1 if not found Insert(int, Node) Inserts a child node at the specified index. This is not supported and will always throw an exception. public void Insert(int index, Node value) Parameters index int value Node Exceptions NotSupportedException Lookup(object) Looks up a child node by key. If the node is a Term, the first child is used as the base node. If the node is an Object or Set, the child with the specified key is returned. For other node types, an exception is thrown. public Node Lookup(object key) Parameters key object The key to look up. Returns Node The child node with the specified key Exceptions NotSupportedException KeyNotFoundException RegoException Remove(Node) Removes the specified child node. This is not supported and will always throw an exception. public bool Remove(Node value) Parameters value Node Returns bool Exceptions NotSupportedException RemoveAt(int) Removes the child node at the specified index. This is not supported and will always throw an exception. public void RemoveAt(int index) Parameters index int Exceptions NotSupportedException ToJson() Returns a JSON representation of this node. The JSON is cached after the first call. public string ToJson() Returns string a JSON string representation of this node Exceptions RegoException ToString() Returns a JSON representation of this node. This is the same as calling ToJson(). public override string ToString() Returns string the JSON representation of this node TryGetValue(object, out Node?) Tries to get the child node with the specified key. If the node is a Term, the first child is used as the base node. If the node is an Object or Set, the keys are checked. For other node types, an exception is thrown. The comparison is done by comparing the JSON representation of the keys. public bool TryGetValue(object key, out Node? value) Parameters key object the key to look up value Node when this method returns, contains the child node associated with the specified key, if the key is found; otherwise, null Returns bool true if the key was found; otherwise, false"
  },
  "api/Rego.NodeType.html": {
    "href": "api/Rego.NodeType.html",
    "title": "Enum NodeType | Rego",
    "summary": "Enum NodeType Namespace Rego Assembly Rego.dll Node types for Rego AST nodes public enum NodeType Fields Array = 1004 , An array of terms Binding = 1000 A binding of a variable to a term Bindings = 1016 A list of bindings Error = 1800 An error node, containing an error message, an error AST, and an error code ErrorAst = 1802 An error AST showing where in the code tree the error occurred ErrorCode = 1803 An error code ErrorMessage = 1801 An error message ErrorSeq = 1804 An error sequence False = 1012 A boolean value representing false Float = 1009 A floating point value Int = 1008 An integer value Internal = 1999 An internal node type, not exposed to users Null = 1013 A null value Object = 1006 An object, which is a collection of ObjectItem nodes ObjectItem = 1007 An item in an object, which is a key-value pair. The first child is the key, the second child is the value. Result = 1018 A result, consiting of a list of bindings and a list of terms Results = 1017 A list of results Scalar = 1003 A scalar value (int, float, string, true, false, null) Set = 1005 A set of terms. Will not contain duplicates. String = 1010 A string value Term = 1002 A term, which can be a scalar, array, set, or object Terms = 1015 A list of terms True = 1011 A boolean value representing true Undefined = 1014 An undefined value Var = 1001 A variable"
  },
  "api/Rego.Output.html": {
    "href": "api/Rego.Output.html",
    "title": "Class Output | Rego",
    "summary": "Class Output Namespace Rego Assembly Rego.dll public class Output Inheritance object Output Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Properties Count The number of results in the output. public int Count { get; } Property Value int Handle The underlying Rego output handle. public RegoOutputHandle Handle { get; } Property Value RegoOutputHandle Node The root node of the output. public Node Node { get; } Property Value Node Ok Indicates whether the output is valid. public bool Ok { get; } Property Value bool Methods Binding(int, string) Returns the binding with the specified name at the specified index. If the index is out of range, an ArgumentOutOfRangeException is thrown. If the name does not exist, an empty node is returned. public Node Binding(int index, string name) Parameters index int Index into the result set name string Name of the binding Returns Node The binding node, or an empty node if not found Exceptions ArgumentOutOfRangeException Binding(string) Returns the binding with the specified name at index 0. If the name does not exist, an empty node is returned. public Node Binding(string name) Parameters name string Name of the binding Returns Node The binding node, or an empty node if not found Expressions() Returns the expressions at index 0. If there are no expressions, an empty node is returned. public Node Expressions() Returns Node The expressions node, or an empty node if not found Expressions(int) Returns the expressions at the specified index. If the index is out of range, an ArgumentOutOfRangeException is thrown. The expressions are returned as a node. If there are no expressions, an empty node is returned. public Node Expressions(int index) Parameters index int The index into the result set Returns Node The expressions node, or an empty node if not found Exceptions ArgumentOutOfRangeException ToString() Returns a JSON representation of the output. public override string ToString() Returns string The JSON string representation of the output Exceptions RegoException"
  },
  "api/Rego.RegoBundleHandle.html": {
    "href": "api/Rego.RegoBundleHandle.html",
    "title": "Class RegoBundleHandle | Rego",
    "summary": "Class RegoBundleHandle Namespace Rego Assembly Rego.dll Handle wrapping the pointer to the native Rego bundle object public sealed class RegoBundleHandle : SafeHandle, IDisposable Inheritance object CriticalFinalizerObject SafeHandle RegoBundleHandle Implements IDisposable Inherited Members SafeHandle.Close() SafeHandle.DangerousAddRef(ref bool) SafeHandle.DangerousGetHandle() SafeHandle.DangerousRelease() SafeHandle.Dispose() SafeHandle.SetHandleAsInvalid() SafeHandle.IsClosed object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors RegoBundleHandle() Creates a new invalid handle public RegoBundleHandle() Properties IsInvalid Indicates whether the handle is invalid public override bool IsInvalid { get; } Property Value bool Methods ReleaseHandle() When overridden in a derived class, executes the code required to free the handle. protected override bool ReleaseHandle() Returns bool true if the handle is released successfully; otherwise, in the event of a catastrophic failure, false. In this case, it generates a releaseHandleFailed Managed Debugging Assistant."
  },
  "api/Rego.RegoException.html": {
    "href": "api/Rego.RegoException.html",
    "title": "Class RegoException | Rego",
    "summary": "Class RegoException Namespace Rego Assembly Rego.dll Exception thrown for errors returned from the Rego library public class RegoException : Exception, ISerializable Inheritance object Exception RegoException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors RegoException(string) Exception thrown for errors returned from the Rego library public RegoException(string message) Parameters message string"
  },
  "api/Rego.RegoHandle.html": {
    "href": "api/Rego.RegoHandle.html",
    "title": "Class RegoHandle | Rego",
    "summary": "Class RegoHandle Namespace Rego Assembly Rego.dll Handle wrapping the pointer to the native Rego interpreter object public sealed class RegoHandle : SafeHandle, IDisposable Inheritance object CriticalFinalizerObject SafeHandle RegoHandle Implements IDisposable Inherited Members SafeHandle.Close() SafeHandle.DangerousAddRef(ref bool) SafeHandle.DangerousGetHandle() SafeHandle.DangerousRelease() SafeHandle.Dispose() SafeHandle.SetHandleAsInvalid() SafeHandle.IsClosed object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors RegoHandle() Creates a new invalid handle public RegoHandle() Properties IsInvalid Indicates whether the handle is invalid public override bool IsInvalid { get; } Property Value bool Methods ReleaseHandle() When overridden in a derived class, executes the code required to free the handle. protected override bool ReleaseHandle() Returns bool true if the handle is released successfully; otherwise, in the event of a catastrophic failure, false. In this case, it generates a releaseHandleFailed Managed Debugging Assistant."
  },
  "api/Rego.RegoInputHandle.html": {
    "href": "api/Rego.RegoInputHandle.html",
    "title": "Class RegoInputHandle | Rego",
    "summary": "Class RegoInputHandle Namespace Rego Assembly Rego.dll Handle wrapping the pointer to the native Rego input object public sealed class RegoInputHandle : SafeHandle, IDisposable Inheritance object CriticalFinalizerObject SafeHandle RegoInputHandle Implements IDisposable Inherited Members SafeHandle.Close() SafeHandle.DangerousAddRef(ref bool) SafeHandle.DangerousGetHandle() SafeHandle.DangerousRelease() SafeHandle.Dispose() SafeHandle.SetHandleAsInvalid() SafeHandle.IsClosed object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors RegoInputHandle() Creates a new invalid handle public RegoInputHandle() Properties IsInvalid Indicates whether the handle is invalid public override bool IsInvalid { get; } Property Value bool Methods ReleaseHandle() When overridden in a derived class, executes the code required to free the handle. protected override bool ReleaseHandle() Returns bool true if the handle is released successfully; otherwise, in the event of a catastrophic failure, false. In this case, it generates a releaseHandleFailed Managed Debugging Assistant."
  },
  "api/Rego.RegoNull.html": {
    "href": "api/Rego.RegoNull.html",
    "title": "Class RegoNull | Rego",
    "summary": "Class RegoNull Namespace Rego Assembly Rego.dll Represents a null value in Rego public record RegoNull : IEquatable<RegoNull> Inheritance object RegoNull Implements IEquatable<RegoNull> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/Rego.RegoOutputHandle.html": {
    "href": "api/Rego.RegoOutputHandle.html",
    "title": "Class RegoOutputHandle | Rego",
    "summary": "Class RegoOutputHandle Namespace Rego Assembly Rego.dll Handle wrapping the pointer to the native Rego output object public sealed class RegoOutputHandle : SafeHandle, IDisposable Inheritance object CriticalFinalizerObject SafeHandle RegoOutputHandle Implements IDisposable Inherited Members SafeHandle.Close() SafeHandle.DangerousAddRef(ref bool) SafeHandle.DangerousGetHandle() SafeHandle.DangerousRelease() SafeHandle.Dispose() SafeHandle.SetHandleAsInvalid() SafeHandle.IsClosed object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors RegoOutputHandle() Creates a new invalid handle public RegoOutputHandle() Properties IsInvalid Indicates whether the handle is invalid public override bool IsInvalid { get; } Property Value bool Methods ReleaseHandle() When overridden in a derived class, executes the code required to free the handle. protected override bool ReleaseHandle() Returns bool true if the handle is released successfully; otherwise, in the event of a catastrophic failure, false. In this case, it generates a releaseHandleFailed Managed Debugging Assistant."
  },
  "api/Rego.html": {
    "href": "api/Rego.html",
    "title": "Namespace Rego | Rego",
    "summary": "Namespace Rego Classes Bundle Encapsulates a Rego bundle, which contains compiled virtual documents and execution plans, the base documents merged into a single JSON hierarchy, and assorted metadata, including the original module files. Input The Input class allows the creation of inputs to a policy without requiring serialization to JSON. The interface is that of a stack, in which values are pushed and then various operations are used to turn terminal types into more complex ones like objects and arrays. When used, the Input will provide the top of the stack to any downstream consumer (such as SetInput(Input)). Interpreter Rego interpreter instance. This class provides methods to load modules, data, and input, execute queries, and manage bundles. Logging Logging utilities for Rego Node Interface for a Rego Node. Rego Nodes are the basic building blocks of a Rego result. They exist in a tree structure. Each node has a kind, which is one of the variants of NodeType. Each node also has zero or more children, which are also nodes. Output RegoBundleHandle Handle wrapping the pointer to the native Rego bundle object RegoException Exception thrown for errors returned from the Rego library RegoHandle Handle wrapping the pointer to the native Rego interpreter object RegoInputHandle Handle wrapping the pointer to the native Rego input object RegoNull Represents a null value in Rego RegoOutputHandle Handle wrapping the pointer to the native Rego output object Enums BundleFormat LogLevel Log levels for Rego logging NodeType Node types for Rego AST nodes"
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started | Rego",
    "summary": "Getting Started Here are some examples of usage to help you get started. Querying and Accessing Results Here we see some exa using System.Collections; using Rego; // You can run simple queries without any input or data. Interpreter rego = new(); var output = rego.Query(\"x=5;y=x + (2 - 4 * 0.25) * -3 + 7.4;2 * 5\"); Console.WriteLine(output); // {\"expressions\":[true, true, 10], \"bindings\":{\"x\":5, \"y\":9.4}} // You can access bound results using the Binding method Console.WriteLine(\"x = {0}\", output.Binding(\"x\")); // You can also access expressions by index Console.WriteLine(output.Expressions()[2]); Incorporating Base and Virtual Documents Most policies are built up from a combination of Base Documents (static JSON data) and Virtual Documents (Rego modules). Here we see a typical usage example incorporating all the different components of a Rego policy: // We can add base documents using .NET objects, which will be converted // to JSON and then added. Interpreter rego = new(); var data0 = new Dictionary<string, object>{ {\"one\", new Dictionary<string, object>{ {\"bar\", \"Foo\"}, {\"baz\", 5}, {\"be\", true}, {\"bop\", 23.4}}}, {\"two\", new Dictionary<string, object>{ {\"bar\", \"Bar\"}, {\"baz\", 12.3}, {\"be\", false}, {\"bop\", 42}}}}; rego.AddData(data0); // You can also provide JSON directly. rego.AddDataJson(\"\"\" { \"three\": { \"bar\": \"Baz\", \"baz\": 15, \"be\": true, \"bop\": 4.23 } } \"\"\"); // The Rego code can be written out in-source like this or loaded from disk. var objectsSource = \"\"\" package objects rect := {\"width\": 2, \"height\": 4} cube := {\"width\": 3, \"height\": 4, \"depth\": 5} a := 42 b := false c := null d := {\"a\": a, \"x\": [b, c]} index := 1 shapes := [rect, cube] names := [\"prod\", \"smoke1\", \"dev\"] sites := [{\"name\": \"prod\"}, {\"name\": names[index]}, {\"name\": \"dev\"}] e := { a: \"foo\", \"three\": c, names[2]: b, \"four\": d, } f := e[\"dev\"] \"\"\"; rego.AddModule(\"objects.rego\", objectsSource); // inputs can be either JSON or Rego, and provided as objects (which will // be converted to JSON) or as text. rego.SetInputTerm(\"\"\" { \"a\": 10, \"b\": \"20\", \"c\": 30.0, \"d\": true } \"\"\"); Console.WriteLine(rego.Query(\"[data.one, input.b, data.objects.sites[1]] = x\")); // {\"bindings\":{\"x\":[{\"bar\":\"Foo\", \"baz\":5, \"be\":true, \"bop\":23.4}, \"20\", {\"name\":\"smoke1\"}]}} Bundles If you want to run the same set of queries against a policy with different inputs, you can create a bundle and use that to save the cost of compilation. Interpreter rego_build = new(); rego_build.AddDataJson(\"\"\" {\"a\": 7, \"b\": 13} \"\"\"); rego_build.AddModule(\"example.rego\", \"\"\" package example foo := data.a * input.x + data.b * input.y bar := data.b * input.x + data.a * input.y \"\"\"); // We can specify both a default query, and specific entry points into the policy // that should be made available to use later. var bundle = rego_build.Build(\"x=data.example.foo + data.example.bar\", [\"example/foo\", \"example/bar\"]); // we can now save the bundle to the disk rego_build.SaveBundle(\"bundle\", bundle); // and load it again Interpreter rego_run = new(); rego_run.LoadBundle(\"bundle\"); // the most efficient way to provide input to a policy is by constructing it // manually, without the need for parsing JSON or Rego. var input = Input.Create(new Dictionary<string, int> { {\"x\", 104 }, {\"y\", 119 } }); rego_run.SetInput(input); // We can query the bundle, which will use the entrypoint of the default query // provided at build Console.WriteLine(\"query: {0}\",rego_run.QueryBundle(bundle)); // Query: {\"expressions\":[true], \"bindings\":{\"x\":4460}} // or we can query specific entrypoints Console.WriteLine(\"example/foo: {0}\", rego_run.QueryBundle(bundle, \"example/foo\")); // example/foo: {\"expressions\":[2275]}"
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "| Rego",
    "summary": "What is Rego? Rego is a language developed by Open Policy Agent (OPA) for use in defining policies in cloud systems. We think Rego is a great language, and you can learn more about it from the OPA website. However, it has some limitations. Primarily, the interpreter is only accessible via the command line or a web server. Further, the only option for using the language in-process is via an interface in Go. The rego-cpp project provides the ability to integrate Rego natively into a wider range of languages. We currrently support C, C++, Rust, Python and, via this package, .NET, and are largely compatible with v1.8.0 of the language. You can learn more about our implementation on our Github page."
  },
  "index.html": {
    "href": "index.html",
    "title": "Quick Start | Rego",
    "summary": "Quick Start Evaluate Rego natively in .NET programs easily using this library. Integrating a Policy In this section we will write a Policy class that uses Rego to determine room access in a building. Prerequisites Install .NET SDK 8.0 or higher Make sure you have .NET SDK installed, then open a terminal and enter the following command to install the latest version of Rego: WIP"
  }
}