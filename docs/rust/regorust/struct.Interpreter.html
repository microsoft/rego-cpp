<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Interface for the Rego interpreter."><title>Interpreter in regorust - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="regorust" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../regorust/index.html">regorust</a><span class="version">1.0.0</span></h2></div><h2 class="location"><a href="#">Interpreter</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.add_data_json">add_data_json</a></li><li><a href="#method.add_data_json_file">add_data_json_file</a></li><li><a href="#method.add_module">add_module</a></li><li><a href="#method.add_module_file">add_module_file</a></li><li><a href="#method.build">build</a></li><li><a href="#method.get_debug_enabled">get_debug_enabled</a></li><li><a href="#method.get_log_level">get_log_level</a></li><li><a href="#method.get_strict_built_in_errors">get_strict_built_in_errors</a></li><li><a href="#method.get_well_formed_checks_enabled">get_well_formed_checks_enabled</a></li><li><a href="#method.is_built_in">is_built_in</a></li><li><a href="#method.load_bundle">load_bundle</a></li><li><a href="#method.new">new</a></li><li><a href="#method.query">query</a></li><li><a href="#method.query_bundle">query_bundle</a></li><li><a href="#method.query_bundle_entrypoint">query_bundle_entrypoint</a></li><li><a href="#method.save_bundle">save_bundle</a></li><li><a href="#method.set_debug_enabled">set_debug_enabled</a></li><li><a href="#method.set_debug_path">set_debug_path</a></li><li><a href="#method.set_input">set_input</a></li><li><a href="#method.set_input_json">set_input_json</a></li><li><a href="#method.set_input_json_file">set_input_json_file</a></li><li><a href="#method.set_log_level">set_log_level</a></li><li><a href="#method.set_strict_built_in_errors">set_strict_built_in_errors</a></li><li><a href="#method.set_well_formed_checks_enabled">set_well_formed_checks_enabled</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Debug-for-Interpreter">Debug</a></li><li><a href="#impl-Drop-for-Interpreter">Drop</a></li><li><a href="#impl-PartialEq-for-Interpreter">PartialEq</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Send-for-Interpreter">!Send</a></li><li><a href="#impl-Sync-for-Interpreter">!Sync</a></li><li><a href="#impl-Freeze-for-Interpreter">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Interpreter">RefUnwindSafe</a></li><li><a href="#impl-Unpin-for-Interpreter">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Interpreter">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In crate regorust</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="index.html">regorust</a>::<wbr><a class="struct" href="#">Interpreter</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/regorust/lib.rs.html#141-143">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct Interpreter { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Interface for the Rego interpreter.</p>
<p>This wraps the Rego C API, and handles passing calls to
the C API and converting the results to Rust types.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>rego = Interpreter::new();
<span class="kw">match </span>rego.query(<span class="string">"x=5;y=x + (2 - 4 * 0.25) * -3 + 7.4"</span>) {
  <span class="prelude-val">Ok</span>(result) =&gt; {
    <span class="kw">let </span>x = result.binding(<span class="string">"x"</span>).expect(<span class="string">"cannot get x"</span>);
    <span class="kw">let </span>y = result.binding(<span class="string">"y"</span>).expect(<span class="string">"cannot get y"</span>);
    <span class="macro">println!</span>(<span class="string">"x = {}"</span>, x.json().unwrap());
    <span class="macro">println!</span>(<span class="string">"y = {}"</span>, y.json().unwrap());
  }
  <span class="prelude-val">Err</span>(e) =&gt; {
    <span class="macro">panic!</span>(<span class="string">"error: {}"</span>, e);
  }
}</code></pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>input = <span class="string">r#"
  {
    "a": 10,
    "b": "20",
    "c": 30.0,
    "d": true
  }
"#</span>;
<span class="kw">let </span>data0 = <span class="string">r#"
  {
    "one": {
      "bar": "Foo",
      "baz": 5,
      "be": true,
      "bop": 23.4
    },
    "two": {
      "bar": "Bar",
      "baz": 12.3,
      "be": false,
      "bop": 42
    }
  }
"#</span>;
<span class="kw">let </span>data1 = <span class="string">r#"
  {
    "three": {
      "bar": "Baz",
      "baz": 15,
      "be": true,
      "bop": 4.23
    }
  }        
"#</span>;
<span class="kw">let </span>module = <span class="string">r#"
  package objects

  rect := {`width`: 2, "height": 4}
  cube := {"width": 3, `height`: 4, "depth": 5}
  a := 42
  b := false
  c := null
  d := {"a": a, "x": [b, c]}
  index := 1
  shapes := [rect, cube]
  names := ["prod", `smoke1`, "dev"]
  sites := [{"name": "prod"}, {"name": names[index]}, {"name": "dev"}]
  e := {
    a: "foo",
    "three": c,
    names[2]: b,
    "four": d,
  }
  f := e["dev"]                
"#</span>;
<span class="kw">let </span>rego = Interpreter::new();
rego.set_input_json(input);
rego.add_data_json(data0);
rego.add_data_json(data1);
rego.add_module(<span class="string">"objects"</span>, module);
<span class="kw">match </span>rego.query(<span class="string">"x=[data.one, input.b, data.objects.sites[1]]"</span>) {
  <span class="prelude-val">Ok</span>(result) =&gt; {
    <span class="macro">println!</span>(<span class="string">"{}"</span>, result.to_str().unwrap());
    <span class="kw">let </span>x = result.binding(<span class="string">"x"</span>).expect(<span class="string">"cannot get x"</span>);
    <span class="kw">let </span>data_one = x.index(<span class="number">0</span>).unwrap();
    <span class="kw">if let </span>NodeValue::String(bar) = data_one
        .lookup(<span class="string">"bar"</span>)
        .unwrap()
        .value()
        .unwrap()
    {
      <span class="macro">println!</span>(<span class="string">"data.one.bar = {}"</span>, bar);
    }
  }
  <span class="prelude-val">Err</span>(e) =&gt; {
   <span class="macro">panic!</span>(<span class="string">"error: {}"</span>, e);
  }
}</code></pre></div>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Interpreter" class="impl"><a class="src rightside" href="../src/regorust/lib.rs.html#605-1231">source</a><a href="#impl-Interpreter" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Interpreter.html" title="struct regorust::Interpreter">Interpreter</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../src/regorust/lib.rs.html#607-612">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>() -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a new Rego interpreter.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_log_level" class="method"><a class="src rightside" href="../src/regorust/lib.rs.html#631-648">source</a><h4 class="code-header">pub fn <a href="#method.set_log_level" class="fn">set_log_level</a>(&amp;self, log_level: <a class="enum" href="enum.LogLevel.html" title="enum regorust::LogLevel">LogLevel</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.unit.html">()</a>, &amp;'static <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Sets the level of logging produced by the library.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_log_level" class="method"><a class="src rightside" href="../src/regorust/lib.rs.html#651-664">source</a><h4 class="code-header">pub fn <a href="#method.get_log_level" class="fn">get_log_level</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="enum.LogLevel.html" title="enum regorust::LogLevel">LogLevel</a>, &amp;'static <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Sets the level of logging produced by the library.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_module_file" class="method"><a class="src rightside" href="../src/regorust/lib.rs.html#681-691">source</a><h4 class="code-header">pub fn <a href="#method.add_module_file" class="fn">add_module_file</a>(&amp;self, path: &amp;<a class="struct" href="https://doc.rust-lang.org/1.81.0/std/path/struct.Path.html" title="struct std::path::Path">Path</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;</h4></section></summary><div class="docblock"><p>Adds a Rego module from a file.</p>
<p>The file must be valid Rego, and is equivalent to adding
the module as a string using <code>add_module</code>.</p>
<h5 id="example-module-file"><a class="doc-anchor" href="#example-module-file">§</a>Example module file</h5><div class="example-wrap"><pre class="language-rego"><code>package scalars

greeting := &quot;Hello&quot;
max_height := 42
pi := 3.14159
allowed := true
location := null
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.add_module" class="method"><a class="src rightside" href="../src/regorust/lib.rs.html#713-724">source</a><h4 class="code-header">pub fn <a href="#method.add_module" class="fn">add_module</a>(&amp;self, name: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.str.html">str</a>, source: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;</h4></section></summary><div class="docblock"><p>Adds a Rego module from a string.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>module = <span class="string">r#"
  package scalars

  greeting := "Hello"
  max_height := 42
  pi := 3.14159
  allowed := true
  location := null
"#</span>;
<span class="kw">let </span>rego = Interpreter::new();
rego.add_module(<span class="string">"scalars"</span>, module);
<span class="kw">let </span>result = rego.query(<span class="string">"data.scalars.greeting"</span>).unwrap();
<span class="macro">println!</span>(<span class="string">"{}"</span>, result.to_str().unwrap());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_data_json_file" class="method"><a class="src rightside" href="../src/regorust/lib.rs.html#748-758">source</a><h4 class="code-header">pub fn <a href="#method.add_data_json_file" class="fn">add_data_json_file</a>(&amp;self, path: &amp;<a class="struct" href="https://doc.rust-lang.org/1.81.0/std/path/struct.Path.html" title="struct std::path::Path">Path</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;</h4></section></summary><div class="docblock"><p>Adds a base document from a file.</p>
<p>The file must be a valid JSON object, and is equivalent to adding
the document as a string using <code>add_data_json</code>.</p>
<h5 id="example-document-file"><a class="doc-anchor" href="#example-document-file">§</a>Example document file</h5><div class="example-wrap"><pre class="language-json"><code>{
   &quot;one&quot;: {
       &quot;bar&quot;: &quot;Foo&quot;,
       &quot;baz&quot;: 5,
       &quot;be&quot;: true,
       &quot;bop&quot;: 23.4
   },
   &quot;two&quot;: {
       &quot;bar&quot;: &quot;Bar&quot;,
     &quot;baz&quot;: 12.3,
       &quot;be&quot;: false,
       &quot;bop&quot;: 42
   }
}
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.add_data_json" class="method"><a class="src rightside" href="../src/regorust/lib.rs.html#789-798">source</a><h4 class="code-header">pub fn <a href="#method.add_data_json" class="fn">add_data_json</a>(&amp;self, data: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;</h4></section></summary><div class="docblock"><p>Adds a base document from a string.</p>
<p>The string must contain a valid JSON object.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>data = <span class="string">r#"
  {
    "one": {
      "bar": "Foo",
      "baz": 5,
      "be": true,
      "bop": 23.4
    },
    "two": {
      "bar": "Bar",
      "baz": 12.3,
      "be": false,
      "bop": 42
    }
  }
"#</span>;
<span class="kw">let </span>rego = Interpreter::new();
rego.add_data_json(data);
<span class="kw">let </span>result = rego.query(<span class="string">"data.one.bar"</span>).unwrap();
<span class="macro">println!</span>(<span class="string">"{}"</span>, result.to_str().unwrap());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_input_json_file" class="method"><a class="src rightside" href="../src/regorust/lib.rs.html#821-831">source</a><h4 class="code-header">pub fn <a href="#method.set_input_json_file" class="fn">set_input_json_file</a>(&amp;self, path: &amp;<a class="struct" href="https://doc.rust-lang.org/1.81.0/std/path/struct.Path.html" title="struct std::path::Path">Path</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;</h4></section></summary><div class="docblock"><p>Sets the input JSON expression from a file.</p>
<p>The input must be a single valid JSON value. It is equivalent to adding
the input file as a string using <code>add_input_json</code>.</p>
<h5 id="example-input-files"><a class="doc-anchor" href="#example-input-files">§</a>Example input files</h5><div class="example-wrap"><pre class="language-json"><code>&quot;Hello, rego&quot;
</code></pre></div><div class="example-wrap"><pre class="language-json"><code>42
</code></pre></div><div class="example-wrap"><pre class="language-json"><code>[1, 2, 3]
</code></pre></div><div class="example-wrap"><pre class="language-json"><code>{&quot;a&quot;: 1, &quot;b&quot;: 2}
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.set_input_json" class="method"><a class="src rightside" href="../src/regorust/lib.rs.html#872-881">source</a><h4 class="code-header">pub fn <a href="#method.set_input_json" class="fn">set_input_json</a>(&amp;self, input: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;</h4></section></summary><div class="docblock"><p>Sets the input JSON expression from a string.</p>
<p>The input must be a single valid JSON value.</p>
<h5 id="example-input-files-1"><a class="doc-anchor" href="#example-input-files-1">§</a>Example input files</h5><div class="example-wrap"><pre class="language-json"><code>&quot;Hello, rego&quot;
</code></pre></div><div class="example-wrap"><pre class="language-json"><code>42
</code></pre></div><div class="example-wrap"><pre class="language-json"><code>[1, 2, 3]
</code></pre></div><div class="example-wrap"><pre class="language-json"><code>{&quot;a&quot;: 1, &quot;b&quot;: 2}
</code></pre></div><h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>input = <span class="string">r#"
  {
    "a": 10,
    "b": "20",
    "c": 30.0,
    "d": true
  }
"#</span>;
<span class="kw">let </span>rego = Interpreter::new();
rego.set_input_json(input);
<span class="kw">let </span>result = rego.query(<span class="string">"input.a"</span>).unwrap();
<span class="macro">println!</span>(<span class="string">"{}"</span>, result.to_str().unwrap());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_input" class="method"><a class="src rightside" href="../src/regorust/lib.rs.html#886-893">source</a><h4 class="code-header">pub fn <a href="#method.set_input" class="fn">set_input</a>(&amp;self, input: &amp;<a class="struct" href="struct.Input.html" title="struct regorust::Input">Input</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;</h4></section></summary><div class="docblock"><p>Sets the input for the current policy directly.</p>
<p>See <a href="struct.Input.html" title="struct regorust::Input"><code>Input</code></a> for more information.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_debug_enabled" class="method"><a class="src rightside" href="../src/regorust/lib.rs.html#901-906">source</a><h4 class="code-header">pub fn <a href="#method.set_debug_enabled" class="fn">set_debug_enabled</a>(&amp;self, enabled: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Sets whether the Rego interpreter is in debug mode.</p>
<p>When debug mode is enabled, the Rego interpreter will output extensive
debugging information about the compliation process, including intermediary
ASTs and the generated bytecode. This is mostly useful for debugging the
Rego compiler itself, and is not useful for debugging Rego policies.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_debug_enabled" class="method"><a class="src rightside" href="../src/regorust/lib.rs.html#909-912">source</a><h4 class="code-header">pub fn <a href="#method.get_debug_enabled" class="fn">get_debug_enabled</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns whether the Rego interpreter is in debug mode.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_debug_path" class="method"><a class="src rightside" href="../src/regorust/lib.rs.html#917-927">source</a><h4 class="code-header">pub fn <a href="#method.set_debug_path" class="fn">set_debug_path</a>(&amp;self, path: &amp;<a class="struct" href="https://doc.rust-lang.org/1.81.0/std/path/struct.Path.html" title="struct std::path::Path">Path</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;</h4></section></summary><div class="docblock"><p>Sets the path to the directory where the Rego interpreter will write debug AST files.</p>
<p>This is only useful when debug mode is enabled.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_well_formed_checks_enabled" class="method"><a class="src rightside" href="../src/regorust/lib.rs.html#933-938">source</a><h4 class="code-header">pub fn <a href="#method.set_well_formed_checks_enabled" class="fn">set_well_formed_checks_enabled</a>(&amp;self, enabled: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Sets whether the Rego interpreter will perform well-formedness checks.</p>
<p>When enabled, the Rego interpreter will perform well-formedness checks on
the AST during each pass of the compiler.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_well_formed_checks_enabled" class="method"><a class="src rightside" href="../src/regorust/lib.rs.html#941-944">source</a><h4 class="code-header">pub fn <a href="#method.get_well_formed_checks_enabled" class="fn">get_well_formed_checks_enabled</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns whether the Rego interpreter will perform well-formedness checks.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_strict_built_in_errors" class="method"><a class="src rightside" href="../src/regorust/lib.rs.html#951-956">source</a><h4 class="code-header">pub fn <a href="#method.set_strict_built_in_errors" class="fn">set_strict_built_in_errors</a>(&amp;self, enabled: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Sets whether the interpreter will forward errors thrown by the built-ins.</p>
<p>By default, the Rego interpreter will catch errors thrown by the built-ins
and return them as an Undefined result. When this is enabled, the interpreter
will instead forward the error to the caller.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_strict_built_in_errors" class="method"><a class="src rightside" href="../src/regorust/lib.rs.html#959-962">source</a><h4 class="code-header">pub fn <a href="#method.get_strict_built_in_errors" class="fn">get_strict_built_in_errors</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns whether the interpreter will forward errors thrown by the built-ins.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_built_in" class="method"><a class="src rightside" href="../src/regorust/lib.rs.html#973-978">source</a><h4 class="code-header">pub fn <a href="#method.is_built_in" class="fn">is_built_in</a>(&amp;self, name: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns whether the interpreter has a built-in with the given name.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>rego = Interpreter::new();
<span class="macro">println!</span>(<span class="string">"{}"</span>, rego.is_built_in(<span class="string">"json.unmarshal"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.query" class="method"><a class="src rightside" href="../src/regorust/lib.rs.html#1031-1040">source</a><h4 class="code-header">pub fn <a href="#method.query" class="fn">query</a>(&amp;self, query: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Output.html" title="struct regorust::Output">Output</a>, <a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;</h4></section></summary><div class="docblock"><p>This method performs a query against the current set of base and virtual documents.</p>
<p>While the Rego interpreter can be used to perform simple queries, in most cases
users will want to load one or more base documents (using <a href="struct.Interpreter.html#method.add_data_json" title="method regorust::Interpreter::add_data_json"><code>Self::add_data_json()</code></a> or
<a href="struct.Interpreter.html#method.add_data_json_file" title="method regorust::Interpreter::add_data_json_file"><code>Self::add_data_json_file()</code></a>) and one or more Rego modules (using <a href="struct.Interpreter.html#method.add_module" title="method regorust::Interpreter::add_module"><code>Self::add_module()</code></a> or
<a href="struct.Interpreter.html#method.add_module_file" title="method regorust::Interpreter::add_module_file"><code>Self::add_module_file()</code></a>). Then, multiple queries can be performed by providing an input
(using <a href="struct.Interpreter.html#method.set_input_json" title="method regorust::Interpreter::set_input_json"><code>Self::set_input_json()</code></a> or <a href="struct.Interpreter.html#method.set_input_json_file" title="method regorust::Interpreter::set_input_json_file"><code>Self::set_input_json_file()</code></a>) and then calling this
method.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>input0 = <span class="string">r#"{"a": 10}"#</span>;
<span class="kw">let </span>input1 = <span class="string">r#"{"a": 4}"#</span>;
<span class="kw">let </span>input2 = <span class="string">r#"{"a": 7}"#</span>;
<span class="kw">let </span>multi = <span class="string">r#"
  package multi
   
  default a := 0
   
  a := val {
      input.a &gt; 0
      input.a &lt; 10
      input.a % 2 == 1
      val := input.a * 10
  } {
      input.a &gt; 0
      input.a &lt; 10
      input.a % 2 == 0
      val := input.a * 10 + 1
  }
   
  a := input.a / 10 {
      input.a &gt;= 10
  }
"#</span>;
<span class="kw">let </span>rego = Interpreter::new();
rego.add_module(<span class="string">"multi"</span>, multi);
rego.set_input_json(input0);
<span class="kw">let </span>result = rego.query(<span class="string">"data.multi.a"</span>).unwrap();
<span class="macro">println!</span>(<span class="string">"{}"</span>, result.to_str().unwrap());
rego.set_input_json(input1);
<span class="kw">let </span>result = rego.query(<span class="string">"data.multi.a"</span>).unwrap();
<span class="macro">println!</span>(<span class="string">"{}"</span>, result.to_str().unwrap());
rego.set_input_json(input2);
<span class="kw">let </span>result = rego.query(<span class="string">"data.multi.a"</span>).unwrap();
<span class="macro">println!</span>(<span class="string">"{}"</span>, result.to_str().unwrap());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.build" class="method"><a class="src rightside" href="../src/regorust/lib.rs.html#1080-1116">source</a><h4 class="code-header">pub fn <a href="#method.build" class="fn">build</a>&lt;T: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.str.html">str</a>&gt;&gt;(
    &amp;self,
    query: &amp;<a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt;,
    entrypoints: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.slice.html">[T]</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Bundle.html" title="struct regorust::Bundle">Bundle</a>, <a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;</h4></section></summary><div class="docblock"><p>Build a bundle from the current base and virtual documents, along
with <code>query</code> and the provided <code>entrypoints</code>. There must be at least
one entrypoint or a query in order for the build to be successful.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>input0 = <span class="string">r#"{
    "x": 104,
    "y": 119
}"#</span>;
<span class="kw">let </span>data = <span class="string">r#"{
    "a": 7,
    "b": 13
}"#</span>;
<span class="kw">let </span>module = <span class="string">r#"
 package example

 foo := data.a * input.x + data.b * input.y
 bar := data.b * input.x + data.a * input.y
"#</span>;
<span class="kw">let </span>rego_build = Interpreter::new();
rego_build.add_data_json(data);
rego_build.add_module(<span class="string">"example.rego"</span>, module);
<span class="kw">let </span>bundle = rego_build.build(<span class="kw-2">&amp;</span><span class="prelude-val">Some</span>(<span class="string">"x=data.example.foo + data.example.bar"</span>),
                              <span class="kw-2">&amp;</span>[<span class="string">"example/foo"</span>, <span class="string">"example/bar"</span>]).expect(<span class="string">"Unable to build bundle"</span>);
<span class="kw">let </span>rego_run = Interpreter::new();
rego_run.set_input_json(input0);
<span class="kw">let </span>result = rego_run.query_bundle(<span class="kw-2">&amp;</span>bundle).expect(<span class="string">"Failed bundle query"</span>);
<span class="kw">let </span>x = result.binding(<span class="string">"x"</span>).unwrap();
<span class="macro">println!</span>(<span class="string">"x = {}"</span>, x.json().unwrap());

<span class="kw">let </span>result = rego_run.query_bundle_entrypoint(<span class="kw-2">&amp;</span>bundle, <span class="string">"example/foo"</span>).expect(<span class="string">"Failed bundle entrypoint query"</span>);
<span class="macro">println!</span>(<span class="string">"{}"</span>, result.to_str().unwrap());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.load_bundle" class="method"><a class="src rightside" href="../src/regorust/lib.rs.html#1119-1133">source</a><h4 class="code-header">pub fn <a href="#method.load_bundle" class="fn">load_bundle</a>(
    &amp;self,
    path: &amp;<a class="struct" href="https://doc.rust-lang.org/1.81.0/std/path/struct.Path.html" title="struct std::path::Path">Path</a>,
    format: <a class="enum" href="enum.BundleFormat.html" title="enum regorust::BundleFormat">BundleFormat</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Bundle.html" title="struct regorust::Bundle">Bundle</a>, <a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;</h4></section></summary><div class="docblock"><p>Loads a bundle from the disk.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.save_bundle" class="method"><a class="src rightside" href="../src/regorust/lib.rs.html#1174-1195">source</a><h4 class="code-header">pub fn <a href="#method.save_bundle" class="fn">save_bundle</a>(
    &amp;self,
    path: &amp;<a class="struct" href="https://doc.rust-lang.org/1.81.0/std/path/struct.Path.html" title="struct std::path::Path">Path</a>,
    bundle: &amp;<a class="struct" href="struct.Bundle.html" title="struct regorust::Bundle">Bundle</a>,
    format: <a class="enum" href="enum.BundleFormat.html" title="enum regorust::BundleFormat">BundleFormat</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;</h4></section></summary><div class="docblock"><p>Saves a bundle to the disk.</p>
<p>There are two modes for bundle serialization. The JSON serialization scheme creates
a directory at the specified path and then writes at least two files: <code>plan.json</code>
(which contains the compiled virtual documents and plans for execution) and
<code>data.json</code> (which contains the base documents merged into a single JSON hierarchy).
Module source files will also be copied into the directory.</p>
<p>The second mode is binary serialization. This uses the
<a href="https://microsoft.github.io/rego-cpp/cpp/rbb.html">Rego Binary Bundle format</a>
to create a single file which contains all the bundle information.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>rego_build = Interpreter::new();
<span class="kw">let </span>bundle = rego_build.build(<span class="kw-2">&amp;</span><span class="prelude-val">Some</span>(<span class="string">"a=1"</span>), <span class="kw-2">&amp;</span>[]).expect(<span class="string">"Failed to build bundle"</span>);
<span class="kw">let </span><span class="kw-2">mut </span>bundle_dir = env::temp_dir();
bundle_dir.push(<span class="string">"bundle"</span>);
<span class="kw">let </span><span class="kw-2">mut </span>bundle_file = env::temp_dir();
bundle_file.push(<span class="string">"bundle.rbb"</span>);
rego_build.save_bundle(<span class="kw-2">&amp;</span>bundle_dir, <span class="kw-2">&amp;</span>bundle, BundleFormat::JSON).expect(<span class="string">"Unable to save bundle"</span>);
rego_build.save_bundle(<span class="kw-2">&amp;</span>bundle_file, <span class="kw-2">&amp;</span>bundle, BundleFormat::Binary).expect(<span class="string">"Unable to save binary bundle"</span>);

<span class="kw">let </span>rego_run = Interpreter::new();
<span class="kw">let </span>bundle = rego_run.load_bundle(<span class="kw-2">&amp;</span>bundle_dir, BundleFormat::JSON).expect(<span class="string">"Unable to load bundle from disk"</span>);
<span class="kw">let </span>result = rego_run.query_bundle(<span class="kw-2">&amp;</span>bundle).expect(<span class="string">"Failed bundle query"</span>);
<span class="kw">let </span>a = result.binding(<span class="string">"a"</span>).unwrap();
<span class="macro">println!</span>(<span class="string">"a = {}"</span>, a.json().unwrap());

<span class="kw">let </span>bundle = rego_run.load_bundle(<span class="kw-2">&amp;</span>bundle_file, BundleFormat::Binary).expect(<span class="string">"Unable to load bundle from disk"</span>);
<span class="kw">let </span>result = rego_run.query_bundle(<span class="kw-2">&amp;</span>bundle).expect(<span class="string">"Failed bundle query"</span>);
<span class="kw">let </span>a = result.binding(<span class="string">"a"</span>).unwrap();
<span class="macro">println!</span>(<span class="string">"a = {}"</span>, a.json().unwrap());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.query_bundle_entrypoint" class="method"><a class="src rightside" href="../src/regorust/lib.rs.html#1201-1216">source</a><h4 class="code-header">pub fn <a href="#method.query_bundle_entrypoint" class="fn">query_bundle_entrypoint</a>(
    &amp;self,
    bundle: &amp;<a class="struct" href="struct.Bundle.html" title="struct regorust::Bundle">Bundle</a>,
    entrypoint: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.str.html">str</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Output.html" title="struct regorust::Output">Output</a>, <a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;</h4></section></summary><div class="docblock"><p>Performs a query using the compiled policy in the bundle.</p>
<p>This method requires that the entrypoint specified by <code>entrypoint</code>
was provided to <a href="struct.Interpreter.html#method.build" title="method regorust::Interpreter::build"><code>Interpreter::build()</code></a>. Otherwise, it will fail.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.query_bundle" class="method"><a class="src rightside" href="../src/regorust/lib.rs.html#1222-1230">source</a><h4 class="code-header">pub fn <a href="#method.query_bundle" class="fn">query_bundle</a>(&amp;self, bundle: &amp;<a class="struct" href="struct.Bundle.html" title="struct regorust::Bundle">Bundle</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Output.html" title="struct regorust::Output">Output</a>, <a class="struct" href="https://doc.rust-lang.org/1.81.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;</h4></section></summary><div class="docblock"><p>Performs a query using the compiled policy in the bundle.</p>
<p>This method requires that a query was provided to <a href="struct.Interpreter.html#method.build" title="method regorust::Interpreter::build"><code>Interpreter::build()</code></a>.
Otherwise, it will fail.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Interpreter" class="impl"><a class="src rightside" href="../src/regorust/lib.rs.html#140">source</a><a href="#impl-Debug-for-Interpreter" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Interpreter.html" title="struct regorust::Interpreter">Interpreter</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/regorust/lib.rs.html#140">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.81.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.81.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.81.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Drop-for-Interpreter" class="impl"><a class="src rightside" href="../src/regorust/lib.rs.html#1233-1239">source</a><a href="#impl-Drop-for-Interpreter" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop">Drop</a> for <a class="struct" href="struct.Interpreter.html" title="struct regorust::Interpreter">Interpreter</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.drop" class="method trait-impl"><a class="src rightside" href="../src/regorust/lib.rs.html#1234-1238">source</a><a href="#method.drop" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/ops/drop/trait.Drop.html#tymethod.drop" class="fn">drop</a>(&amp;mut self)</h4></section></summary><div class='docblock'>Executes the destructor for this type. <a href="https://doc.rust-lang.org/1.81.0/core/ops/drop/trait.Drop.html#tymethod.drop">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-Interpreter" class="impl"><a class="src rightside" href="../src/regorust/lib.rs.html#1241-1245">source</a><a href="#impl-PartialEq-for-Interpreter" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="struct" href="struct.Interpreter.html" title="struct regorust::Interpreter">Interpreter</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../src/regorust/lib.rs.html#1242-1244">source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Self</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.81.0/src/core/cmp.rs.html#262">source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Interpreter" class="impl"><a href="#impl-Freeze-for-Interpreter" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.Interpreter.html" title="struct regorust::Interpreter">Interpreter</a></h3></section><section id="impl-RefUnwindSafe-for-Interpreter" class="impl"><a href="#impl-RefUnwindSafe-for-Interpreter" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Interpreter.html" title="struct regorust::Interpreter">Interpreter</a></h3></section><section id="impl-Send-for-Interpreter" class="impl"><a href="#impl-Send-for-Interpreter" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Interpreter.html" title="struct regorust::Interpreter">Interpreter</a></h3></section><section id="impl-Sync-for-Interpreter" class="impl"><a href="#impl-Sync-for-Interpreter" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Interpreter.html" title="struct regorust::Interpreter">Interpreter</a></h3></section><section id="impl-Unpin-for-Interpreter" class="impl"><a href="#impl-Unpin-for-Interpreter" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Interpreter.html" title="struct regorust::Interpreter">Interpreter</a></h3></section><section id="impl-UnwindSafe-for-Interpreter" class="impl"><a href="#impl-UnwindSafe-for-Interpreter" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Interpreter.html" title="struct regorust::Interpreter">Interpreter</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/any.rs.html#140">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/any.rs.html#141">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.81.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.81.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/borrow.rs.html#209">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/borrow.rs.html#211">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/borrow.rs.html#217">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/borrow.rs.html#218">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.81.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/convert/mod.rs.html#765">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/convert/mod.rs.html#768">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/convert/mod.rs.html#748-750">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/convert/mod.rs.html#758">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.81.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/convert/mod.rs.html#805-807">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/convert/mod.rs.html#812">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/convert/mod.rs.html#790-792">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.81.0/src/core/convert/mod.rs.html#797">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>