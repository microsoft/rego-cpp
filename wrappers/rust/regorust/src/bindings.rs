/* automatically generated by rust-bindgen 0.68.1 */

pub const REGOCPP_VERSION_MAJOR: u32 = 0;
pub const REGOCPP_VERSION_MINOR: u32 = 3;
pub const REGOCPP_VERSION_REVISION: u32 = 5;
pub const REGOCPP_OPA_VERSION: &[u8; 7] = b"0.55.0\0";
pub const REGOCPP_VERSION: &[u8; 6] = b"0.3.5\0";
pub const REGOCPP_GIT_HASH: &[u8; 41] = b"d831cc9e40c3419dac73b563c3346b0818925106\0";
pub const REGOCPP_BUILD_NAME: &[u8; 13] = b"main:d831cc9\0";
pub const REGOCPP_BUILD_DATE: &[u8; 32] = b"Tue, 12 Sep 2023 13:02:34 +0100\0";
pub const REGOCPP_BUILD_TOOLCHAIN: &[u8; 19] = b"MSVC 19.37.32822.0\0";
pub const REGOCPP_PLATFORM: &[u8; 8] = b"windows\0";
pub const REGO_OK: u32 = 0;
pub const REGO_ERROR: u32 = 1;
pub const REGO_ERROR_BUFFER_TOO_SMALL: u32 = 2;
pub const REGO_NODE_BINDING: u32 = 1000;
pub const REGO_NODE_VAR: u32 = 1001;
pub const REGO_NODE_TERM: u32 = 1002;
pub const REGO_NODE_SCALAR: u32 = 1003;
pub const REGO_NODE_ARRAY: u32 = 1004;
pub const REGO_NODE_SET: u32 = 1005;
pub const REGO_NODE_OBJECT: u32 = 1006;
pub const REGO_NODE_OBJECT_ITEM: u32 = 1007;
pub const REGO_NODE_INT: u32 = 1008;
pub const REGO_NODE_FLOAT: u32 = 1009;
pub const REGO_NODE_STRING: u32 = 1010;
pub const REGO_NODE_TRUE: u32 = 1011;
pub const REGO_NODE_FALSE: u32 = 1012;
pub const REGO_NODE_NULL: u32 = 1013;
pub const REGO_NODE_UNDEFINED: u32 = 1014;
pub const REGO_NODE_ERROR: u32 = 1800;
pub const REGO_NODE_ERROR_MESSAGE: u32 = 1801;
pub const REGO_NODE_ERROR_AST: u32 = 1802;
pub const REGO_NODE_ERROR_CODE: u32 = 1803;
pub const REGO_NODE_ERROR_SEQ: u32 = 1804;
pub const REGO_NODE_INTERNAL: u32 = 1999;
pub const REGO_LOG_LEVEL_NONE: u32 = 0;
pub const REGO_LOG_LEVEL_ERROR: u32 = 1;
pub const REGO_LOG_LEVEL_WARN: u32 = 2;
pub const REGO_LOG_LEVEL_INFO: u32 = 3;
pub const REGO_LOG_LEVEL_DEBUG: u32 = 4;
pub const REGO_LOG_LEVEL_TRACE: u32 = 5;
pub type regoInterpreter = ::std::os::raw::c_void;
pub type regoNode = ::std::os::raw::c_void;
pub type regoOutput = ::std::os::raw::c_void;
pub type regoEnum = ::std::os::raw::c_uint;
pub type regoBoolean = ::std::os::raw::c_uchar;
pub type regoSize = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Sets the level of logging.\n\n This setting controls the amount of logging that will be output to stdout.\n The default level is REGO_LOG_LEVEL_NONE.\n\n @param level One of the following values: REGO_LOG_LEVEL_NONE,\n              REGO_LOG_LEVEL_ERROR, REGO_LOG_LEVEL_WARN,\n              REGO_LOG_LEVEL_INFO, REGO_LOG_LEVEL_DEBUG,\n              REGO_LOG_LEVEL_TRACE."]
    pub fn regoSetLogLevel(level: regoEnum);
}
extern "C" {
    #[doc = " Allocates and initializes a new Rego interpreter.\n\n The caller is responsible for freeing the interpreter with regoFree.\n\n @return A pointer to the new interpreter."]
    pub fn regoNew() -> *mut regoInterpreter;
}
extern "C" {
    #[doc = " Frees a Rego interpreter.\n\n This pointer must have been allocated with regoNew.\n\n @param rego The interpreter to free."]
    pub fn regoFree(rego: *mut regoInterpreter);
}
extern "C" {
    #[doc = " Adds a module (e.g. virtual document) from the file at the\n specified path.\n\n If an error code is returned, more error information can be\n obtained by calling regoGetError.\n\n @param rego The interpreter.\n @param path The path to the policy file.\n @return REGO_OK if successful, REGO_ERROR otherwise."]
    pub fn regoAddModuleFile(
        rego: *mut regoInterpreter,
        path: *const ::std::os::raw::c_char,
    ) -> regoEnum;
}
extern "C" {
    #[doc = " Adds a module (e.g. virtual document) from the specified string.\n\n If an error code is returned, more error information can be\n obtained by calling regoGetError.\n\n @param rego The interpreter.\n @param name The name of the module.\n @param contents The contents of the module.\n @return REGO_OK if successful, REGO_ERROR otherwise."]
    pub fn regoAddModule(
        rego: *mut regoInterpreter,
        name: *const ::std::os::raw::c_char,
        contents: *const ::std::os::raw::c_char,
    ) -> regoEnum;
}
extern "C" {
    #[doc = " Adds a base document from the file at the specified path.\n\n The file should contain a single JSON object. The object will be\n parsed and merged with the interpreter's base document.\n\n If an error code is returned, more error information can be\n obtained by calling regoGetError.\n\n @param rego The interpreter.\n @param path The path to the JSON file.\n @return REGO_OK if successful, REGO_ERROR otherwise."]
    pub fn regoAddDataJSONFile(
        rego: *mut regoInterpreter,
        path: *const ::std::os::raw::c_char,
    ) -> regoEnum;
}
extern "C" {
    #[doc = " Adds a base document from the specified string.\n\n The string should contain a single JSON object. The object will be\n parsed and merged with the interpreter's base document.\n\n If an error code is returned, more error information can be\n obtained by calling regoGetError.\n\n @param rego The interpreter.\n @param contents The contents of the JSON object.\n @return REGO_OK if successful, REGO_ERROR otherwise."]
    pub fn regoAddDataJSON(
        rego: *mut regoInterpreter,
        contents: *const ::std::os::raw::c_char,
    ) -> regoEnum;
}
extern "C" {
    #[doc = " Sets the current input document from the file at the specified path.\n\n The file should contain a single JSON value. The value will be\n parsed and set as the interpreter's input document.\n\n If an error code is returned, more error information can be\n obtained by calling regoGetError.\n\n @param rego The interpreter.\n @param path The path to the JSON file.\n @return REGO_OK if successful, REGO_ERROR otherwise."]
    pub fn regoSetInputJSONFile(
        rego: *mut regoInterpreter,
        path: *const ::std::os::raw::c_char,
    ) -> regoEnum;
}
extern "C" {
    #[doc = " Sets the current input document from the specified string.\n\n The string should contain a single JSON value. The value will be\n parsed and set as the interpreter's input document.\n\n If an error code is returned, more error information can be\n obtained by calling regoGetError.\n\n @param rego The interpreter.\n @param contents The contents of the JSON value.\n @return REGO_OK if successful, REGO_ERROR otherwise."]
    pub fn regoSetInputJSON(
        rego: *mut regoInterpreter,
        contents: *const ::std::os::raw::c_char,
    ) -> regoEnum;
}
extern "C" {
    #[doc = " Sets the debug mode of the interpreter.\n\n When debug mode is enabled, the interpreter will output intermediary\n ASTs after each compiler pass to the debug directory and output pass\n information to stdout. This is mostly useful for creating reports for\n compiler issues, but can also be of use in understanding why a policy is\n invalid or is behaving unexpectedly.\n\n @param rego The interpreter.\n @param enabled Whether debug mode should be enabled."]
    pub fn regoSetDebugEnabled(rego: *mut regoInterpreter, enabled: regoBoolean);
}
extern "C" {
    #[doc = " Gets the debug mode of the interpreter.\n\n @param rego The interpreter.\n @return Whether debug mode is enabled."]
    pub fn regoGetDebugEnabled(rego: *mut regoInterpreter) -> regoBoolean;
}
extern "C" {
    #[doc = " Sets the path to the debug directory.\n\n If set, then (when in debug mode) the interpreter will output intermediary\n ASTs after each compiler pass to the debug directory. If the directory does\n not exist, it will be created.\n\n If an error code is returned, more error information can be\n obtained by calling regoGetError.\n\n @param rego The interpreter.\n @param path The path to the debug directory.\n @return REGO_OK if successful, REGO_ERROR otherwise."]
    pub fn regoSetDebugPath(
        rego: *mut regoInterpreter,
        path: *const ::std::os::raw::c_char,
    ) -> regoEnum;
}
extern "C" {
    #[doc = " Sets whether to perform well-formed checks after each compiler pass.\n\n The interpreter has a set of well-formness definitions which indicate the\n expected form of the AST before and after each compiler pass. This setting\n determines whether the interpreter will perform these intermediary checks.\n\n @param rego The interpreter.\n @param enabled Whether well-formed checks should be enabled."]
    pub fn regoSetWellFormedChecksEnabled(rego: *mut regoInterpreter, enabled: regoBoolean);
}
extern "C" {
    #[doc = " Gets whether well-formed checks are enabled.\n\n @param rego The interpreter.\n @return Whether well-formed checks are enabled."]
    pub fn regoGetWellFormedChecksEnabled(rego: *mut regoInterpreter) -> regoBoolean;
}
extern "C" {
    #[doc = " Performs a query against the current base and virtual documents.\n\n The query expression should be a Rego query. The output of the query\n will be returned as a regoOutput object. The caller is responsible for\n freeing the output object with regoFreeOutput.\n\n @param rego The interpreter.\n @param query_expr The query expression.\n @return The output of the query."]
    pub fn regoQuery(
        rego: *mut regoInterpreter,
        query_expr: *const ::std::os::raw::c_char,
    ) -> *mut regoOutput;
}
extern "C" {
    #[doc = " Sets whether the built-ins should throw errors.\n\n When strict built-in errors are enabled, built-in functions will throw\n errors when they encounter invalid input. When disabled, built-in\n functions will return undefined when they encounter invalid input.\n\n @param rego The interpreter.\n @param enabled Whether strict built-in errors should be enabled."]
    pub fn regoSetStrictBuiltInErrors(rego: *mut regoInterpreter, enabled: regoBoolean);
}
extern "C" {
    #[doc = " Gets whether strict built-in errors are enabled.\n\n @param rego The interpreter.\n @return Whether strict built-in errors are enabled."]
    pub fn regoGetStrictBuiltInErrors(rego: *mut regoInterpreter) -> regoBoolean;
}
extern "C" {
    #[doc = " Returns the most recently thrown error.\n\n If an error code is returned from an interface function, more error\n information can be obtained by calling this function.\n\n @param rego The interpreter.\n @return The error message."]
    pub fn regoGetError(rego: *mut regoInterpreter) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns whether the output is ok.\n\n If the output resulted in a valid query result, then this function will\n return true. Otherwise, it will return false, indicating that the\n output contains an error sequence.\n\n @param output The output.\n @return Whether the output is ok."]
    pub fn regoOutputOk(output: *mut regoOutput) -> regoBoolean;
}
extern "C" {
    #[doc = " Returns the node containing the output of the query.\n\n This will either be a node which contains sequence of terms and/or\n bindings, or an error sequence.\n\n @param output The output.\n @return The output node."]
    pub fn regoOutputNode(output: *mut regoOutput) -> *mut regoNode;
}
extern "C" {
    #[doc = " Returns the bound value for a given variable name.\n\n If the variable is not bound, then this function will return NULL.\n\n @param output The output.\n @param name The variable name.\n @return The bound value (or NULL if the variable was not bound)"]
    pub fn regoOutputBinding(
        output: *mut regoOutput,
        name: *const ::std::os::raw::c_char,
    ) -> *mut regoNode;
}
extern "C" {
    #[doc = " Returns the output represented as a human-readable string.\n\n @param output The output.\n @return The output string."]
    pub fn regoOutputString(output: *mut regoOutput) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Frees a Rego output.\n\n This pointer must have been allocated with regoQuery.\n\n @param output The output to free."]
    pub fn regoFreeOutput(output: *mut regoOutput);
}
extern "C" {
    #[doc = " Returns an enumeration value indicating the nodes type.\n\n This type will be one of the following values:\n\n\n | Name | Description |\n | ---- | ----------- |\n | REGO_NODE_BINDING | A binding. Will have two children, a REGO_NODE_VAR and a REGO_NODE_TERM |\n | REGO_NODE_VAR | A variable name. |\n | REGO_NODE_TERM | A term. Will have one child of: REGO_NODE_SCALAR, REGO_NODE_ARRAY, REGO_NODE_SET, REGO_NODE_OBJECT |\n | REGO_NODE_SCALAR | A scalar value. Will have one child of: REGO_NODE_INT, REGO_NODE_FLOAT, REGO_NODE_STRING, REGO_NODE_TRUE, REGO_NODE_FALSE, REGO_NODE_NULL, REGO_NODE_UNDEFINED |\n | REGO_NODE_ARRAY | An array. Will have one or more children of: REGO_NODE_TERM |\n | REGO_NODE_SET | A set. Will have one or more children of: REGO_NODE_TERM |\n | REGO_NODE_OBJECT | An object. Will have one or more children of: REGO_NODE_OBJECT_ITEM |\n | REGO_NODE_OBJECT_ITEM | An object item. Will have two children, a REGO_NODE_TERM (the key) and a REGO_NODE_TERM (the value) |\n | REGO_NODE_INT | An integer value. |\n | REGO_NODE_FLOAT | A floating point value. |\n | REGO_NODE_STRING | A string value. |\n | REGO_NODE_TRUE | A true value. |\n | REGO_NODE_FALSE | A false value. |\n | REGO_NODE_NULL | A null value. |\n | REGO_NODE_UNDEFINED | An undefined value. |\n | REGO_NODE_ERROR | An error. Will have three children: REGO_NODE_ERROR_MESSAGE, REGO_NODE_ERROR_AST, and REGO_NODE_ERROR_CODE |\n | REGO_NODE_ERROR_MESSAGE | An error message. |\n | REGO_NODE_ERROR_AST | An error AST. |\n | REGO_NODE_ERROR_CODE | An error code. |\n | REGO_NODE_ERROR_SEQ | An error sequence. Will have one or more children of: REGO_NODE_ERROR |\n | REGO_NODE_INTERNAL | An internal node. Use regoNodeTypeName to get the full value. |\n\n @return The node type."]
    pub fn regoNodeType(node: *mut regoNode) -> regoEnum;
}
extern "C" {
    #[doc = " Returns the name of the node type as a human-readable string.\n\n This function supports arbitrary nodes (i.e. it will always produce a\n value) including internal nodes which appear in error messages.\n\n @param node The node.\n @return The node type name."]
    pub fn regoNodeTypeName(node: *mut regoNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the number of bytes needed to store a 0-terminated string\n representing the text value of the node.\n\n The value returned by this function can be used to allocate a buffer to\n pass to regoNodeValue.\n\n @param node The node.\n @return The number of bytes needed to store the text value."]
    pub fn regoNodeValueSize(node: *mut regoNode) -> regoSize;
}
extern "C" {
    #[doc = " Populate a buffer with the node value.\n\n The buffer must be large enough to hold the value. The size of the buffer\n can be determined by calling regoNodeValueSize.\n\n @param node The node.\n @param buffer The buffer to populate.\n @param size The size of the buffer.\n @return REGO_OK if successful, REGO_ERROR_BUFFER_TOO_SMALL otherwise."]
    pub fn regoNodeValue(
        node: *mut regoNode,
        buffer: *mut ::std::os::raw::c_char,
        size: regoSize,
    ) -> regoEnum;
}
extern "C" {
    #[doc = " Returns the number of children of the node.\n\n @param node The node.\n @return The number of children."]
    pub fn regoNodeSize(node: *mut regoNode) -> regoSize;
}
extern "C" {
    #[doc = " Returns the child node at the specified index.\n\n @param node The node.\n @param index The index of the child.\n @return The child node."]
    pub fn regoNodeGet(node: *mut regoNode, index: regoSize) -> *mut regoNode;
}
extern "C" {
    #[doc = " Returns the number of bytes needed to store a 0-terminated string\n representing the JSON representation of the node.\n\n The value returned by this function can be used to allocate a buffer to\n pass to regoNodeJSON.\n\n @param node The node.\n @return The number of bytes needed to store the JSON representation."]
    pub fn regoNodeJSONSize(node: *mut regoNode) -> regoSize;
}
extern "C" {
    #[doc = " Populate a buffer with the JSON representation of the node.\n\n The buffer must be large enough to hold the value. The size of the buffer\n can be determined by calling regoNodeJSONSize.\n\n @param node The node.\n @param buffer The buffer to populate.\n @param size The size of the buffer.\n @return REGO_OK if successful, REGO_ERROR_BUFFER_TOO_SMALL otherwise."]
    pub fn regoNodeJSON(
        node: *mut regoNode,
        buffer: *mut ::std::os::raw::c_char,
        size: regoSize,
    ) -> regoEnum;
}
